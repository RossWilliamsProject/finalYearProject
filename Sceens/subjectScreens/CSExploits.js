//Imports
import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';

//Learning materials for "Exploits" computer security subject
export default function CSExploits() {
  return (
    <View style={styles.backgroundview}>
      <ScrollView
        contentContainerStyle={styles.contentContainer}>
        <View style={styles.view}>
          <Text style={styles.textHeader}>
            Exploits
          </Text>
          <Text style={styles.boldtext}>
            Memory Exploits
          </Text>
          <Text style={styles.text}>
            In C and C++, the programmer performs memory management.{"\n"}
            This is flexible, powerful, fast, but dangerous.{"\n"}
            It leaves the system open to the following exploits:{"\n"}
            •	Buffer Overruns{"\n"}
            •	Stack Overruns{"\n"}
            •	Heap Overruns{"\n"}{"\n"}

          </Text>

          <Text style={styles.boldtext}>
            Buffer Overflows
          </Text>
          <Text style={styles.text}>
            When a program is executed, contiguous blocks of memory can be
            allocated to store arrays (buffers).{"\n"}
            If data is written into a buffer that exceeds its size,
            an overflow occurs.{"\n"}
            The data will overwrite the memory beyond the buffer.{"\n"}
            The stack holds information on local variables and functions calls (stack frames){"\n"}
            -	A function call will push a new frame onto the stack{"\n"}
            -	A return will pop it off, and go to ret{"\n"}{"\n"}
          </Text>

          <Text style={styles.boldtext}>
            Stack Smashing
          </Text>
          <Text style={styles.text}>
            Stack Smashing involves overwriting the buffer, and the return address.{"\n"}
            If done properly, the return address can be overwritten with an address
            of the malicious programmer’s desire – meaning it can be used to inject malicious code.{"\n"}
            The following methods can be used to prevent stack smashing:{"\n"}
            -	Data Execution Prevention (NX){"\n"}
            {"  "}-	Marking the stack as non-executable.{"\n"}
            {"  "}- This can be circumvented using a return-to-libc attack{"\n"}
            -	To defeat ret2libc various 0x0 null bytes are
            inserted into standard library addresses{"\n"}
            -	Developers also restrict access to obvious system calls{"\n"}
            -	Address Space Layout Randomisation (ASLR)
            moves the address of library and programs around{"\n"}{"\n"}

          </Text>

          <Text style={styles.boldtext}>
            Return-Oriented Programming
          </Text>
          <Text style={styles.text}>
            Forget about injecting code, how about just using existing code
            in the actual exploitable program?{"\n"}
            No individual section of this program will do what we want.{"\n"}
            However, by using a carefully constructed chain of short sections
            of existing code (named “gadgets”) linked together with returns,
            technically any program can be created. {"\n"}
            This is dangerous, and very hard to prevent.{"\n"}
            Luckily, it is extremely difficult to program.{"\n"}{"\n"}

          </Text>

          <Text style={styles.boldtext}>
            Race Conditions
          </Text>
          <Text style={styles.text}>
            With concurrent threads or processes, timing can lead to security vulnerabilities.{"\n"}
          </Text>

          <Text style={styles.boldtext}>
            Exploit Usage Example
          </Text>
          <Text style={styles.text}>
            Heartbleed is a bug in OpenSSL – an exploit exists to specifically target
            the heartbeat extension – buffer over-read.{"\n"}
            In heartbeat, a message sent by the client to the server
            is sent back to prove a connection.{"\n"}
            In short, by sending a small message, but telling the server
            it is large (and therefore overflowing the buffer),
            the servers memory will be copied and send back to the client.{"\n"}{"\n"}
          </Text>

        </View>
      </ScrollView>
    </View>

  );
}


const styles = StyleSheet.create({
  view: {
    flex: 0,
    width: "93%",
    borderRadius: 20,
    backgroundColor: "white"
  },
  textHeader: {
    color: 'black',
    paddingLeft: 10,
    paddingTop: 10,
    fontWeight: 'bold',
    fontSize: 30
  },
  text: {
    paddingLeft: 15,
    fontSize: 20
  },
  boldtext: {
    fontWeight: 'bold',
    paddingLeft: 10,
    fontSize: 20
  },
  checkbox: {
    alignSelf: "center",
  },
  space: {
    width: 20,
    height: 10,
  },
  contentContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#D9E3E5',
    paddingBottom: 10,
    paddingTop: 20,
    width: '100%',

  }
})